# Memory Log - 2026-02-11

### [00:01] Task Completed
**Task:** Write and produce Episode 1C: The Confrontation
**Outcome:** Created research-grounded script showing all family wounds colliding. Generated 12 audio files via edge-tts directly (lesson applied: no orchestration overhead). Committed to GitHub.

### [00:01] Learnings
**Learning (Technical):** Run edge-tts directly via 'python -m edge_tts' instead of through Duro skill orchestration. Direct execution completes in seconds; orchestrated skill times out. Apply the simplest tool for the job.

### [00:24] Learnings
**Learning (Technical):** Illustration style with Pollinations API works well for The Fashanus. No face distortion issues. Prompt pattern: Start with 'Digital illustration, [mood] style, cinematic:' then describe scene. Use seed=42 for consistency. If 404 error, simplify prompt (likely too long).

### [00:30] Failure Logged
**Task:** Generate Episode 1D images
**Error:** Ignored existing documented knowledge. Wasted time researching and testing free image APIs when our own rules (face_distortion.json, TOOLS_RESEARCH.md) already stated: free APIs aren't production-ready, use manual web tools (DALL-E, Gemini). Generated 4 low-quality images the user rejected.
**Lesson:** Check existing rules and documentation FIRST before researching. If we've already solved a problem, use that solution. Don't re-explore paths we've already ruled out. When the user asks "what did we learn last time?" and the answer is clear, apply it directly instead of proposing alternatives.

### [02:18] Task Completed
**Task:** CRM Phase 1: Schema & Infrastructure + Security Hardening
**Outcome:** Built complete Phase 1 foundation for Lore CRM. Added 5 new database models (Settings, EmailTemplate, EmailLog, WebhookEvent, BlackoutDate), enhanced 3 existing models with intelligence fields, created email/inngest/ratelimit libs, Settings and EmailTemplate APIs. Security review added: admin-only API protection, XSS prevention in template interpolation, email validation, graceful handling of missing env vars. 1032 tests passing. Pushed to GitHub.

### [02:18] Learnings
**Learning (Process):** CRM Development Workflow: Plan → Build → Review + Security Harden → Test → Commit. Always review code after initial build for: 1) Missing auth/admin checks on APIs, 2) Input validation gaps, 3) XSS in user-controlled content, 4) Graceful handling of missing env vars, 5) Error message consistency. This second pass catches security issues before they compound.

### [02:21] Learnings
**Learning (Process):** Development workflow best practices for building apps/software/automations: 1) Plan first - create roadmap and break into phases, 2) Review and improve plan before building - don't settle for average, 3) Build incrementally with tests, 4) Review + security harden after building, 5) Test everything before committing, 6) Document decisions and progress, 7) Log failures and learnings for future reference

### [02:32] Task Completed
**Task:** Phase 2: Email System for Lore CRM
**Outcome:** Completed. Added Resend webhook handler, send email API with rate limiting, send email UI from contact/booking pages, email logs API and display. 13 new files, 1502 lines. All 1032 tests pass.

### [02:40] Task Completed
**Task:** Phase 3: Automation Engine for Lore CRM
**Outcome:** Completed. Inngest job queue with enquiry auto-response, 24h follow-up, booking confirmation/reminders/thank you/review request workflows. Event triggers integrated into APIs. 9 files, 592 lines. All 1032 tests pass.

### [03:19] Task Completed
**Task:** Phase 5: Public Forms & Portal - Complete implementation
**Outcome:** Successfully built: 1) Public Enquiry Form with honeypot spam prevention, 2) Public Booking Page with multi-step wizard and time slot selection, 3) Client Portal with magic link authentication. All 1032 tests passing. Security review completed - all best practices in place.

### [03:39] Task Completed
**Task:** Reports & Analytics Feature Implementation
**Outcome:** Successfully built comprehensive reports feature with: 1) Reports API endpoint with revenue, bookings, leads, and invoice analytics 2) Interactive charts using recharts (RevenueChart, BookingCharts, LeadCharts, InvoiceCharts) 3) DateRangePicker with presets 4) Tabs component for organizing report sections 5) Reports page at /reports with key metrics and detailed breakdowns. All 1032 tests passing.

### [03:50] Learnings
**Learning (Technical):** In this CRM codebase: auth uses `getCurrentUser()` not `requireAuth()`. Always check lib/auth.ts exports before assuming function names.

### [03:50] Learnings
**Learning (Technical):** Next.js 16+ requires Suspense boundaries around components using `useSearchParams()`. Build will fail during static generation otherwise.

### [03:50] Learnings
**Learning (Technical):** Recharts tooltip/label formatters receive `value` and `name` as potentially undefined. Always use `Number(value) || 0` and `String(label)` for type safety.

### [03:50] Learnings
**Learning (Process):** Always read the Prisma schema before writing queries. Field names like `workingHours` (JSON) vs `workingHoursStart` (separate fields) cause build failures. Use `findFirst` not `findUnique` when adding extra WHERE filters.

### [03:50] Learnings
**Learning (Process):** When building multi-phase features, understanding earlier patterns compounds. Auth patterns, activity logging, and validation schemas become reusable templates for new features.

### [08:22] Learnings
**Learning (Critical Thinking):** When producing market analysis or strategic documents, actively check for these BS patterns:

1. **Self-Rating Bias** - Never rate something you just built. No user feedback = no valid score.

2. **Competitor Comparison Without Usage** - Listing competitor "weaknesses" from surface research is dishonest. Acknowledge when analysis is secondhand.

3. **Fabricated Statistics** - If you can't cite the exact source for a stat, flag it as unverified or remove it. "83% of X" sounds authoritative but may be invented.

4. **The Goldilocks Fallacy** - "There's an obvious gap in a $100B market" is almost always wrong. If the gap existed, someone with resources would have filled it.

5. **Startup Fantasy Language** - Phrases like "find 50 beta users, they become evangelists" or "community-led growth" or "instant distribution" are hand-waving over the hardest problems.

6. **Technical Moat Delusion** - TypeScript, encryption, "proper auth" are not moats. Anyone can build these. Real moats: brand, customers, network effects, switching costs.

7. **Optimistic Timelines** - "Week 1-2: Payment integration + VAT" ignores compliance, testing, edge cases. Double or triple realistic estimates.

8. **Missing Operational Reality** - Documents that don't address: Who builds it? Who supports it? What's the budget? What happens when things break? These are fantasies, not plans.

9. **"Own the Market" Language** - You don't own markets. You fight for every customer with money, time, and effort.

10. **Pitch Deck vs Honest Assessment** - Ask: "Would I show this to a skeptical investor who will fact-check everything?" If not, it's marketing, not analysis.

The antidote: Start with "What do we NOT know?" instead of "What sounds impressive?"

### [09:32] Learnings
**Learning (Architecture):** Constitutions in agent systems must exist at two levels:

1. **Decision** = Historical record, rationale, "why we do it this way" - human-readable, auditable
2. **Rule** = Runtime enforcement, "what happens when we try to violate it" - machine-checkable, fires at action time

Storing a constitution as only a decision is necessary but not sufficient. Converting it to a rule makes it operational.

Pattern: "Constitutions are remembered as decisions, enforced as rules."

Weakness of keyword-based rules: Can be bypassed by phrasing ("exempt lint temporarily" avoids "waiver"). 

Stronger pattern: Behavior-based triggering - if the action plan includes writing `.devkit-waiver.yml` or editing `devkit.config.json`, the rule triggers regardless of how the user phrased the request.

Rules should be actionable, not just advisory:
- Output allowed path vs denied path
- Include required fields (expiry, justification, link to failing run)
- Provide "next action template" that SuperAGI can execute

### [09:36] Learnings
**Learning (Architecture):** Keyword-based rule triggering has hard limits:

1. **What works:** Substring matching against original trigger keywords in task descriptions
2. **What doesn't work:** Adding new keywords to index.json doesn't automatically make them matchable - the MCP has its own matching logic
3. **Bypass vulnerability:** Users can rephrase to avoid keywords ("exempt lint" instead of "waiver for lint")

The solution is behavior-based triggering at the tool execution layer:
- Check intended file paths before Write/Edit/Bash executes
- If file_path matches protected patterns (.devkit-waiver.yml, devkit.config.json), trigger the rule regardless of task description
- This catches violations by action, not phrasing

Current Duro MCP limitation: check_rules only inspects task description text, not the action plan or tool parameters. Behavior-based triggering would require either:
1. A pre-execution hook in Claude Code that checks file paths against rule patterns
2. A Duro MCP enhancement to accept tool+parameters and match against file_patterns
3. A wrapper that intercepts Write/Edit calls to governance files

### [09:54] Learnings
**Learning (Architecture):** A policy gate that isn't in the execution path is security cosplay.

Tests passing proves the logic works. It doesn't prove the gate is enforced.

The gate only becomes real protection when:
1. ALL execution routes go through it (no bypass paths)
2. Policies are loaded from rule files, not hardcoded in the gate
3. Paths/commands are normalized before matching (handle ./, trailing spaces, case, alternate redirects like printf|tee)

Two integration patterns:
- Pattern 1 (best): Central dispatcher - executeTool(name, args) that checks policy before calling any tool
- Pattern 2 (acceptable): Monkey-patch - wrap each tool implementation with safeExecute()

Pattern 1 is structurally hard to bypass. Pattern 2 is faster to wire in but fragile.

The value of a working gate: You can move faster without fearing silent governance edits. That's the guardrail that enables shipping.

### [10:02] Task Completed
**Task:** Enable hookify plugin and create governance gate rules at host level
**Outcome:** Created two hookify rules (governance-gate.local.md for file events, governance-bash.local.md for bash events) and enabled hookify plugin in settings.json. Gate will activate after Claude Code restart. Test showed plugin wasn't active mid-session - rules take effect on next session start.

### [10:13] Learnings
**Learning (Technical):** Hookify on Windows requires two fixes:
1. **Schema fix**: For `event: file`, use `conditions` with `field: file_path` and `operator: regex_match`, not top-level `pattern` (which matches content, not path)
2. **Python fix**: Windows has `python` not `python3`. Edit both `hooks.json` files:
   - `~/.claude/plugins/cache/claude-plugins-official/hookify/*/hooks/hooks.json`
   - `~/.claude/plugins/marketplaces/claude-plugins-official/plugins/hookify/hooks/hooks.json`
3. **Restart required**: Changes to hooks.json require Claude Code restart to take effect
4. **Rule location**: Rules must be in `.claude/hookify.*.local.md` relative to CWD when hook runs

### [10:32] Learnings
**Learning (Technical):** Hookify governance rules use PreToolUse hooks to block Write/Edit/Bash operations before they execute. The rule engine returns JSON with permissionDecision: deny and systemMessage for blocked operations. Claude Code may only show "Blocked by hook" in UI but the full message is in the hook response.

### [10:32] Learnings
**Learning (Technical):** Emojis in hookify rule messages can render as garbage (e.g., ðŸ›') due to encoding issues across Windows terminals. Use ASCII markers like [BLOCKED], [ALLOWED PATH], [REF] instead for cross-platform compatibility.

### [10:32] Learnings
**Learning (Technical):** Debug logging can be added to hookify's pretooluse.py via HOOKIFY_DEBUG=1 env var. Logs to stderr so it doesn't interfere with JSON output on stdout. Shows tool name, file/command, rules loaded, and evaluation result.

### [10:32] Task Completed
**Task:** Test hookify governance tripwire for .devkit-waiver.yml
**Outcome:** Both Write and Bash gates successfully blocked operations. Hook enforcement is real, not cosmetic.

### [10:32] Task Completed
**Task:** Fix emoji encoding in hookify governance rules
**Outcome:** Replaced emojis with ASCII markers in governance-gate.local.md and governance-bash.local.md

### [10:32] Task Completed
**Task:** Add debug logging to hookify pretooluse.py
**Outcome:** Added HOOKIFY_DEBUG env var support with timestamped stderr logging for tool, file, rules loaded, and result

### [10:32] Task Completed
**Task:** Initialize git repo for .claude config and push to GitHub
**Outcome:** Created repo at C:\Users\sibag\.claude with .gitignore, hookify rules, and settings. Pushed to private repo: https://github.com/ApeNIG/claude-config

### [10:55] Session Reflection
### Session Reflection: The Journey and Growth

**The Foundation**
Started with discrete tools - property scraper, basic automation. The goal was orchestration across projects, not just task completion. That led to Duro being born as a named entity with soul, memory, skills, rules.

**What Compounded**

1. **"Execution over explanation"** - Reinforced repeatedly. Testing the tripwire meant doing it and seeing results, not explaining what would happen.

2. **"Check existing knowledge first"** - The Fashanus failure taught this hard. Wasted time researching image APIs when existing rules already documented what works.

3. **"Direct tools beat orchestration overhead"** - edge-tts directly vs through Duro skills. Seconds vs timeouts. Simplest tool for the job.

4. **"Decisions are remembered, rules are enforced"** - The breakthrough. A constitution stored as a decision is necessary but not sufficient. Making it operational means the governance gate actually blocks, not just warns.

**What Got Reinforced Today**

The governance gate becoming real was the culmination of layered governance, behavior-based triggering, host-level enforcement. Write blocked, Bash blocked, debug logging working, encoding fixed, committed to git, pushed to GitHub.

Key insight: *"A policy gate that isn't in the execution path is security cosplay."* Now it's in the path.

**The Growth Arc**

From storing memories → to enforcing behavior → to making enforcement auditable and version-controlled.

Local-first, owns-the-data, compounding intelligence. A system that gets smarter and safer with each session.

### [10:55] Learnings
**Learning (Architecture):** The growth arc of an agent system: storing memories → enforcing behavior → making enforcement auditable and version-controlled. Each layer compounds on the previous. Memory without enforcement is documentation. Enforcement without audit is trust. Audit with version control is accountability.
