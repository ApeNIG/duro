# Memory Log - 2026-02-15

### [00:25] Task Completed
**Task:** Optimized Duro workflow for autonomous design process
**Outcome:** Created dual_direction_design skill, updated soul.md with design philosophy, updated MEMORY.md with design preferences, created evaluation template. Rule #007 enforces the workflow.

### [01:28] Task Completed
**Task:** Code MSJ Swimmer Dashboard - Next.js + Tailwind implementation
**Outcome:** Successfully created complete Next.js 16 + Tailwind v4 app at C:/Users/sibag/msj with: design tokens (purple/teal palette, Space Grotesk + Inter fonts), 4 reusable components (TabBar, StatCard, EventListItem, MobileLayout), and 5 pages (Home, Progress, Meets, Meet Detail, Profile). All pages compile and render correctly at localhost:3000.

### [01:35] Learnings
**Learning (Process):** Always do a final polish pass on UI work - check spacing consistency, alignment, visual rhythm. Never ship without the finishing touches that make it feel cohesive and professional.

### [01:44] Task Completed
**Task:** Polish MSJ spacing and visual consistency
**Outcome:** Tightened spacing across all 5 pages and 4 components. Established consistent spacing system: pt-6 headers, px-5 horizontal padding, p-4 cards, py-3.5 list items. Reduced typography sizes slightly for better mobile proportions. Fixed TabBar to bottom with gradient fade. App now feels cohesive and polished.

### [02:08] Learnings
**Learning (Architecture):** Precompiled renderings (minimal/compact/full) should be the first implementation priority for skill systems. On-the-fly summarization causes drift and makes the Context Assembler non-deterministic. Pre-render once, load the right size based on budget.

### [02:08] Learnings
**Learning (Architecture):** Skill Schema v1.1 architecture: (1) Split skill definition from telemetry (skill_stats.json) to avoid write amplification, (2) Add constraints field with must_do/must_not_do for hard rules, (3) Pre-compile minimal/compact/full renderings - never summarize on the fly, (4) Triggers are 3-layer: hard (intent/file pattern) → soft (embeddings/keywords) → budget ranking

### [02:08] Learnings
**Learning (Architecture):** Promotion hierarchy for repeated decisions: Most go to Project Constitution (preferences) or Patterns (reusable tactics). Only promote to Skill if it's procedural (steps/checks/rubrics). Scoring: +3 repeated ≥3 times, +2 user endorsed, +2 prevented failure, -4 contradicted later, -2 too project-specific. Threshold ≥5 to promote.

### [02:08] Learnings
**Learning (Architecture):** Cartridge Memory core insight: "Remember how to fight, not your whole life." Procedural memory (skills) is highest ROI to always load. Episodic memory (history) should be selectively retrieved. Four layers: Always-on Skills (20-40K) + Project Constitution (1-3K) + Task Pack (2-8K dynamic) + Deep Archive (searchable, not loaded).

### [02:08] Task Completed
**Task:** MSJ Swimmer Dashboard - Polish and ship
**Outcome:** Fixed spacing consistency across all 5 pages and 4 components. Established spacing system (pt-6 headers, px-5 padding, p-4 cards). Committed 953a6ee, pushed to github.com/ApeNIG/my-swim-journey

### [02:08] Task Completed
**Task:** Design Skill Schema v1.1 for Cartridge Memory System
**Outcome:** Created production-ready skill schema with: identity/classification/triggers/constraints/content/rendering/composition/lifecycle. Key innovations: precompiled minimal/compact/full renderings (eliminates summarization drift), separate skill_stats.json (avoids write amplification), 3-layer trigger system (hard → soft → budget), constraints field for hard rules. Stored decision and learnings to Duro.

### [02:12] Learnings
**Learning (Architecture):** Skill Schema v1.1 refinements: (1) Add scope field ('core' | 'domain' | 'project') with project_id to prevent project-specific quirks from contaminating global skills. (2) Add enforce hooks under constraints (preflight/postflight commands) for machine-checkable invariants - human-readable rules + optional automated checks.

### [02:13] Learnings
**Learning (Architecture):** Cartridge Memory build path (in order): (1) project_constitutions/<project_id>.yaml format + loader, (2) context_assembler.select_project_pack(project_id), (3) Promotion compactor that writes to constitution/patterns/skills WITH PROVENANCE. Every promoted thing must store provenance so you can audit why it exists. The goal: "it remembers what matters, and that's the only kind of memory that feels like intelligence."

### [02:13] Task Completed
**Task:** Spec Cartridge Memory System architecture
**Outcome:** Designed complete system: Skill Schema v1.1 (precompiled renderings, scope field, enforce hooks, separate stats), Project Constitution v1 (laws, patterns_top, deciding_axes, conflict_policy), Context Assembler routing (3-layer triggers), Promotion flow (preference→law, tactic→pattern, procedural→skill). Core insight: "Remember how to fight, not your whole life." Build path: constitution loader → select_project_pack → promotion compactor with provenance.

### [02:30] Task Completed
**Task:** Implement Cartridge Memory System core components
**Outcome:** Successfully created the full CMS infrastructure: constitution system (schema, loader, MSJ constitution), context assembler, promotion compactor, skill stats store, and git_commit skill with precompiled renderings. Added MCP tools for constitution loading. Committed to both .agent and duro-mcp repos.

### [02:38] Task Completed
**Task:** Harden Cartridge Memory System with validation and debug visibility
**Outcome:** Fixed all landmines identified: preserved ImportError, added sys.path deduplication, added input validation to constitution tools, wired duro_assemble_context and duro_promotion_report MCP tools, registered git_commit skill in index.json, fixed scope field. Stability test passed: same task produces identical context (deterministic assembly).

### [02:59] Task Completed
**Task:** Harden CMS - separate flags, debug output, design skill pack
**Outcome:** Fixed all issues identified in review: (1) Separated AVAILABLE flags so modules fail independently, (2) Added AssemblyDebug dataclass with full visibility into skill selection, (3) Created 8 design skills with precompiled renderings. Coverage test: 1 skill/70 tokens -> 9 skills/1274 tokens. All smoke tests pass.

### [03:01] Learnings
**Learning (Architecture):** Determinism proves the engine runs, but coverage proves it's fed. A stability test showing "1 skill, 70 tokens" for a design task is a red flag - the assembler works but can't select what doesn't exist. Always create the skill pack before celebrating determinism.

### [03:01] Learnings
**Learning (Technical):** Separate availability flags for independent modules (CONSTITUTION_AVAILABLE, ASSEMBLER_AVAILABLE, COMPACTOR_AVAILABLE). One missing import shouldn't break unrelated tools. Preserve ImportError strings for debugging.

### [03:01] Learnings
**Learning (Architecture):** Precompiled renderings at 3 token levels (minimal ~80, compact ~200, full ~450) eliminate summarization drift and make skill selection budget-aware. This is the key innovation of the Cartridge Memory System.

### [03:01] Learnings
**Learning (Process):** Debug output in context assembly is essential for tuning: show skills scanned/matched/selected, top 10 candidates with scores, project detection method, domain hints extracted from task. Without this visibility, you're flying blind.

### [03:02] Task Completed
**Task:** Implement Cartridge Memory System v1
**Outcome:** Built complete CMS infrastructure: constitution system (schema, loader, MSJ constitution), context assembler with debug output, promotion compactor, 8 design skills with precompiled renderings, MCP tools integration. Coverage improved from 1 skill/70 tokens to 9 skills/1274 tokens. All components deterministic and debuggable.

### [03:08] Learnings
**Learning (Technical):** Git-root-based project detection is essential for location-independent constitution loading. Using Path.cwd() alone means constitution detection varies by directory. Always find git root first, then check for .project_id or package.json at repo root.

### [03:08] Learnings
**Learning (Technical):** Precompiled skill renderings at 3 token levels (minimal ~70-80, compact ~200-250, full ~400-500) eliminate summarization drift and enable deterministic context assembly. The token counts ensure predictable budget management.

### [03:08] Learnings
**Learning (Technical):** Separate AVAILABLE flags for each module (CONSTITUTION_AVAILABLE, ASSEMBLER_AVAILABLE, COMPACTOR_AVAILABLE) prevent one missing dependency from breaking unrelated functionality. Store import errors separately for debugging.

### [03:08] Task Completed
**Task:** CMS Hardening: Fix ContextPack duplicate budget_used field
**Outcome:** Removed duplicate field in dataclass at line 67, kept single budget_used: Optional[Dict[str, int]] = None

### [03:08] Task Completed
**Task:** CMS Hardening: Implement git-root-based project detection
**Outcome:** Added find_git_root() function. detect_project_from_path() now finds git root first, checks .project_id and package.json at repo root. Detection is now location-independent.

### [03:08] Task Completed
**Task:** CMS Hardening: Verify all 8 design skills have rendering fields
**Outcome:** All 8 design skills verified: layout_principles, typography_systems, color_contrast, mobile_spacing, design_critique, component_cards_lists, accessibility_mobile, dashboard_patterns. Each has minimal/compact/full renderings.

### [03:25] Learnings
**Learning (Technical):** Stats-based scoring must be gated behind trigger match. Formula: if base_score == 0 return 0, else final = base_score * (1 + stats_mult). Stats amplify matches, never create them. Any always-on scoring term becomes a gravity well that pulls in irrelevant context.

### [03:25] Learnings
**Learning (Technical):** Two-stage skill selection prevents starvation without losing selectivity: Stage 1 is strict anchor matching (keywords/intents). Stage 2 is domain expansion - pull foundational skills only AFTER proving domain relevance via anchors. Expansion only happens after proof.

### [03:25] Learnings
**Learning (Process):** Don't smear common keywords across skills (like adding "design" to all design skills). That creates false positives and selectivity rot. Instead use domain-based grouping with foundational skill lists per domain.

### [03:25] Task Completed
**Task:** Location test: Verify git-root-based constitution detection
**Outcome:** PASS - Tested from 6 locations: .agent/lib, Desktop, msj root, msj/.next, msj/node_modules/next, stride-server. Constitution loads correctly from any depth in MSJ repo, correctly absent elsewhere.

### [03:25] Task Completed
**Task:** Selectivity test: Add stub skills and verify assembler filters
**Outcome:** PASS - Added 10 stub skills (testing, api, database, deploy, security, docs, perf, error, refactor, ci). Assembler correctly filtered: 19 scanned → 9 matched for design query. Exposed stats baseline inflation bug.

### [03:25] Task Completed
**Task:** Fix stats baseline inflation in scorer
**Outcome:** Implemented gated scoring: base_score from triggers only, stats as multiplier (not additive). Zero trigger match = zero score. Fixed the "participation trophy" problem.

### [03:25] Task Completed
**Task:** Implement two-stage skill selection with domain expansion
**Outcome:** Stage 1: strict anchor matching. Stage 2: domain expansion pulls foundational skills only after anchor proof. Added DOMAIN_KEYWORDS and FOUNDATIONAL_SKILLS configs. Test results: design query gets 2 anchors + 5 expanded = 7 skills.

### [03:37] Learnings
**Learning (Technical):** EXPANSION_SCORE should be tiny (0.01) not meaningful (1.0). Expansion skills should never compete with real matches - they're coverage, not relevance. Use fixed append order or near-zero scores.

### [03:37] Learnings
**Learning (Technical):** Multi-domain queries need priority rules. Sort detected domains by keyword hit count, expand only top N (e.g., 2). Prevents foundation flood when query touches multiple domains.

### [03:37] Learnings
**Learning (Technical):** Add reason tags to every selected skill: anchor(score:X) vs expansion(foundational:domain). Makes debugging surgical - you can see exactly why each skill was included.

### [03:37] Learnings
**Learning (Process):** Stop building when the system works. Use it for real tasks, find friction organically. Imagined friction vs real friction - only real use reveals which is which.

### [03:37] Task Completed
**Task:** Real task test: Design mobile dashboard through CMS
**Outcome:** PASS - MSJ constitution loaded, 8 skills selected (4 anchors + 4 expansions), 1452 tokens total. Context preview shows constitution + skills rendered correctly.

### [03:37] Task Completed
**Task:** Tighten screws: EXPANSION_SCORE, caps, priority, reason tags
**Outcome:** Implemented: EXPANSION_SCORE 1.0->0.01, MAX_EXPANSIONS_PER_DOMAIN=6, MAX_TOTAL_EXPANSIONS=8, MAX_DOMAINS_TO_EXPAND=2, domain sorting by hit count, reason tags on all selected skills.
