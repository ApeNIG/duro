# Memory Log - 2026-02-17

### [02:16] Learnings
**Learning (Creative):** AI video production with stock images + TTS = technically works but emotionally flat. For narrative content like The Fashanus, need: (1) consistent character imagery, (2) real voice acting or better voice direction, (3) music/ambient soundscape, (4) motion on stills. The pipeline works; the craft needs more.

### [02:17] Learnings
**Learning (Technical):** Phase 4.4 production testing validated the full Duro eval pipeline: episode → actions → close → evaluate → apply. Confidence deltas work correctly (+0.01 per reinforcement). System is production-ready for tracking creative workflows.

### [02:17] Learnings
**Learning (Technical):** edge-tts is free and works well for prototyping voiceovers, but lacks emotional range needed for narrative content. Voice assignment: en-GB-SoniaNeural for British female characters. Rate parameter (-10% to -15%) helps with pacing.

### [02:17] Learnings
**Learning (Technical):** moviepy 2.x API changes: use `resized(new_size=)` not `resize(newsize=)`, use `with_duration()` not `set_duration()`, use `with_audio()` not `set_audio()`. Effects API changed significantly - skip fades for quick prototypes.

### [02:17] Task Completed
**Task:** Phase 4.4 Production Testing - complete session
**Outcome:** Completed both synthetic episode test and real production test (The Fashanus Episode 1). Eval pipeline validated. Produced 35-sec video at $0 cost. User feedback: technically works but emotionally flat - need consistent characters, real voice acting, music. Key learning: pipeline works, craft needs more.

### [02:41] Learnings
**Learning (Architecture):** Keyword-gated retrieval creates blind spots for new domains. Proactive recall failed for 'design' because it wasn't in RETRIEVAL_TRIGGERS. Every new skill domain would have the same problem. Semantic search should be the default path.

### [02:52] Task Completed
**Task:** Implemented Option C semantic-first proactive recall architecture
**Outcome:** Modified proactive.py to always search semantically regardless of hot path classification. Keywords now boost scores (+0.05 per tag overlap) instead of gating access. Changed search_mode to 'semantic_first', lowered min_confidence to 0.2. This fix applies to ALL skill domains - current and future - without requiring keyword additions for each new domain.

### [02:52] Learnings
**Learning (Architecture):** Keyword-based retrieval gating creates blind spots for new skill domains. Semantic search should always run first, with keywords boosting relevance rather than blocking access. This ensures memory works for any domain without manual keyword additions.

### [03:45] Learnings
**Learning (Technical):** When debugging "vec_score always 0" issues in Duro semantic search: (1) First verify the database has cosine distance configured with migration status check, (2) Test vector_search directly with Python to confirm embeddings work, (3) Check for key name mismatches between hybrid_search output and explain_score input - the actual keys are "vec_score" and "fts_score", not "vector" and "bm25".

### [03:45] Learnings
**Learning (Technical):** The Duro MCP database is at index.db (not index.sqlite). Path: ~/.agent/memory/index.db. Always check MCP server config (settings.json) for actual paths before debugging.

### [03:45] Task Completed
**Task:** Debug and fix vec_score showing 0.00 in Duro semantic search
**Outcome:** Found key name mismatch in ranking_config.py:explain_score() - was looking for "vector"/"bm25" but hybrid_search creates "vec_score"/"fts_score". Fixed lines 290 and 299. Cosine distance migration was correctly applied, embeddings work fine (0.70+ similarity scores), only the explain text display was wrong.

### [03:51] Task Completed
**Task:** Test and commit explain_score key name fix
**Outcome:** Verified vec_score/fts_score keys work correctly, committed and pushed fix (97eceea)

### [03:51] Task Completed
**Task:** Commit and push pending duro-mcp changes
**Outcome:** Committed 5 changes: semantic-first proactive recall, deferred startup, embeddings fallback, design autocapture category, and 2 migrations. All pushed to origin (bdf736a)

### [03:51] Learnings
**Learning (Technical):** When refactoring dict key names (e.g., "vector" to "vec_score"), search entire codebase for all usages - downstream functions like explain_score may reference old keys and silently return defaults instead of actual values.

### [04:48] Learnings
**Learning (Process):** When debugging recurring problems, always investigate root cause not just symptoms. Recent changes (like new server setups) are prime suspects. Think about the full system: multiple machines, sync mechanisms, shared repos, CI/CD. When user points to a clue, follow it immediately.

### [04:48] Learnings
**Learning (Technical):** Design workout progression: Start with maximum constraints (B&W, one font, no icons) to prove clarity, then layer in systems (grid, spacing, one accent), then add style with purpose. The 20% trim test genuinely improves designs - removing secondary CTAs, detail paragraphs, and obvious labels sharpens focus.

### [04:48] Task Completed
**Task:** Design Workout: LORE CRM Landing Page (3 rounds)
**Outcome:** Completed all 3 rounds. R1: B&W clarity (passed). R2: Systems with 8pt grid + accent (40/50). R3: Quiet Luxury with iterations (45/50). Applied 20% trim and conversion optimizations (mockup, metrics, testimonial, transformation narrative).

### [04:48] Task Completed
**Task:** Fix Duro MCP config sync conflict
**Outcome:** Root cause: DigitalOcean server auto-syncing Linux paths to shared GitHub repo, overwriting Windows config. Fix: Added config.json to .gitignore, created config.default.json template. Each platform now keeps its own config.

### [05:21] Learnings
**Learning (Process):** Build instrumentation, not frameworks. The framework (3-pass loop, 48-hour rule, change ledger) only becomes behavior when it's encoded as tools with enforced workflows. Willpower doesn't scale; tools do.

### [05:21] Learnings
**Learning (Technical):** New Duro artifact types for debugging: incident_rca (6-field RCA), recent_change (change ledger), design_reference (taste library), checklist_template (process templates). Query recent changes with duro_query_recent_changes(hours=48, risk_tags=[...]) for the 48-hour rule.

### [05:21] Learnings
**Learning (Technical):** Identity logging on service startup prevents "mystery bugs": log hostname, git commit, config path, db path. Created new_service_checklist template with code snippets for Python and Node.

### [05:21] Task Completed
**Task:** Build Duro instrumentation system for root cause analysis
**Outcome:** Added 4 new artifact types (incident_rca, recent_change, design_reference, checklist_template), 5 new MCP tools, created new_service_checklist template. All tests pass, pushed to both duro-mcp and .agent repos.

### [05:21] Task Completed
**Task:** Design Workout: LORE CRM Landing Page
**Outcome:** Completed 3 rounds (B&W clarity, Systems, Quiet Luxury). Final score 45/50. Applied 20% trim and conversion optimizations. Learnings saved to .claude/learnings/

### [05:21] Task Completed
**Task:** Fix Duro MCP config sync conflict (root cause analysis)
**Outcome:** Root cause: DO server auto-syncing Linux paths to shared GitHub repo. Fix: Added config.json to .gitignore, created config.default.json template. First incident_rca artifact created as proof of concept.

### [05:42] Learnings
**Learning (Architecture):** When building enforcement mechanisms (gates, guardrails), put enforcement INSIDE the storage function, not as a separate ritual. Users won't remember to call a separate check - but they can't avoid the storage function. The debug gate works because it's in store_incident, not a separate validate_before_close tool.

### [05:42] Learnings
**Learning (Process):** For debugging discipline: the 3-pass sequence is Repro → Boundary → Causality (with 48h scan). The 48-hour scan is only useful AFTER you know what boundary you're looking at. Order matters.

### [05:42] Learnings
**Learning (Process):** Ban handwaving prevention phrases programmatically: "be careful", "remember to", "double check", "pay attention". Force actionable prevention with verb + artifact pattern (e.g., "Add startup log", "Assert X exists", "Add smoke test").

### [05:42] Task Completed
**Task:** Build Debug Gate enforcement for Duro incident RCA
**Outcome:** Shipped hard gate in store_incident: 3 passes (repro, boundary, causality+48h scan) + actionable prevention check. Override mechanism with waiver trail. Auto-runs 48h scan, infers risk_tags. New helper tools: debug_gate_start, debug_gate_status. Committed 6fc8a97, pushed to origin.

### [05:42] Learnings
**Learning (User Preference):** At session end, proactively run learn-and-log without being asked: save learnings, log tasks, offer to commit. Don't wait for the user to say "learn and log" - compound automatically.

### [06:03] Learnings
**Learning (Architecture):** Don't invent new bureaucracy when the primitive exists. Before creating new artifact types, ask: "Can I enhance what I have?" Phase 1 proves the habit works; Phase 2 earns the complexity. decision_review artifact type is Phase 2 value - only build it after proving I'll actually review things.

### [06:03] Learnings
**Learning (Architecture):** Validation should be append-only to preserve time-series learning. Current truth lives on the decision record (status), but each validation is stored as a separate linked entry. This gives audit history without artifact bloat.

### [06:03] Learnings
**Learning (Process):** The surfacing mechanism is the real win. Can't review what you can't see. duro_list_unreviewed_decisions is more valuable than fancy review workflows - it creates the trigger for the habit.

### [06:03] Learnings
**Learning (UX):** Auto-populate context before prompting for judgment. Don't make humans (or agents) do archaeology. duro_review_decision should fetch linked episodes, incidents, age, due date automatically before asking for expected vs actual outcome.

### [06:03] Learnings
**Learning (Process):** Diagnose before fixing. The 4 FTS rows missing semantic text: first identify them, find the shared pattern (creation pathway, migration edge case), add a guard to prevent recurrence, THEN patch. Fixing without understanding means it recurs.

### [06:03] Task Completed
**Task:** Duro status check, health check, and maintenance report
**Outcome:** System operational: 2000 artifacts, 99.8% embedding coverage, 0 queue pending. Minor issue: 4 FTS rows missing semantic text.

### [06:03] Task Completed
**Task:** Reflective analysis: Duro evolution and growth areas
**Outcome:** Identified design as biggest growth area (feedback loops exist, taste compounds). Identified decision validation as key gap - 148 decisions stored, unknown if they worked. This is the next growth frontier.

### [06:03] Task Completed
**Task:** Critical analysis of Decision Closure System spec
**Outcome:** Challenged initial spec. Found existing duro_validate_decision tool. Proposed Option B: enhance existing primitives instead of new artifact type. Key additions: duro_list_unreviewed_decisions (surfacing), append-only validation history, auto-context in review flow. User confirmed this is the right approach.
