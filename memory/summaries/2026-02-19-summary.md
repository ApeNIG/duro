# Summary: 2026-02-19

## Learnings
- AI Agent Worker Architecture for BrandForge: Can replace rule-based workers with intelligent agents using Claude SDK + tool use. Architecture: BullMQ queue → Agent Service → Claude (with tools) → Tool handlers (Puppeteer, DB, Duro memory). Agent has agentic loop where Claude decides tool order, applies fixes intelligently, learns from experience via Duro. Key tools: render_template, run_qa_checks, apply_fix, save_asset, duro_recall, duro_learn, analyze_image (vision). Created in agent-worker/ directory with full implementation.
- User preference: Always explore FREE/open-source alternatives before recommending paid solutions (like Claude API). Look for: Ollama + local LLMs, LangChain with free models, Hugging Face models, open-source agent frameworks (AutoGPT, CrewAI with free backends), self-hosted options.
- Policy gates must be in the execution path, not advisory. A "policy gate" that agents optionally call is security cosplay. The gate must be the first thing executed in every tool handler, with fail-closed behavior if the autonomy system is unavailable.
- Approval tokens must be scoped to the exact action (tool_name:args_hash), not just the tool. If the arguments change, a new approval is required. This prevents "approve delete files" from being reused for any file.
- Audit logs should store structured metadata + hashes, not raw arguments. Redact sensitive keys (password, token, secret, api_key), high-entropy strings (tokens), and convert paths to workspace-relative. Full args can go to a separate restricted debug log.
- Path traversal protection must check BOTH before AND after path resolution. Symlinks can be used to bypass pre-resolution checks by pointing to locations outside the workspace. Always resolve paths to their real locations before checking workspace membership.
- duro_workspace_add is a privilege escalation tool - treat it like sudo. Adding a workspace should require approval and be constrained to user directories unless breakglass. An unrestricted workspace_add lets agents eventually rummage through anything.
- Secrets must be redacted in THREE places: (1) gate audit logging, (2) any tool that writes memory/artifacts, (3) any tool that logs outputs. If you only redact in one place, secrets leak through the others. Redact both inputs AND outputs - CLI tools echoing tokens is an exfil pipeline.
- Workspace privilege escalation: Adding paths outside home directory should require explicit approval. The `duro_workspace_add` tool is essentially `sudo` for file access - treat it accordingly with one-shot approval tokens.
- One-shot token consumption must happen AFTER the permission check but BEFORE the action. Check `permission.allowed_via_token` and immediately consume the token when True to prevent replay attacks.

## Tasks Completed
- BrandForge MVP - QA fixes, demo mode, agent worker architecture: Fixed QA rules (minFontSize 24, safeMargin 30), added demo mode to auth, created full agent-worker architecture with Claude SDK + tools + Duro memory integration. All 5 original tasks completed. Batch rendering works end-to-end with approve/download.
- Implement execution-path policy gate for Duro MCP server: Created policy_gate.py with: GateDecision dataclass, fail-closed behavior, breakglass override (DURO_POLICY_BREAKGLASS env), bypass set for introspection tools, redaction functions, audit logging to gate_decisions.jsonl. Integrated at top of call_tool() - every tool call now passes through the gate. Updated duro_grant_approval to use scoped action IDs (tool_name:args_hash). Added duro_gate_audit tool to query audit log. Tests passing.
- Fix one-shot token consumption and commit policy gate: Fixed token consumption: when permission.allowed_via_token=True, gate now consumes the token before allowing action. Tested: grant approval -> first call succeeds (token consumed) -> second call blocked. Committed to branch security/policy-gate-exec-path with 880 insertions.
- Implement workspace guard (Layer 2 security): Created workspace_guard.py with: path scoping to DURO_WORKSPACE, path traversal detection (.., symlinks, unicode confusables), high-risk path patterns requiring approval (.env, credentials, .ssh), bash command path extraction. Integrated into policy gate - workspace check runs after autonomy approval. Default workspace is ~/.agent. Added tools: duro_workspace_status, duro_workspace_add, duro_workspace_validate. All tests passing, pushed to security/policy-gate-exec-path branch.
- Complete Layer 2 security - workspace guard with path scoping: Implemented workspace_guard.py with DURO_WORKSPACE scoping, path traversal detection, symlink resolution, unicode normalization, high-risk file patterns. Integrated into policy gate. Pushed to security/policy-gate-exec-path. Two follow-up items identified: (1) verify one-shot approval consumption works, (2) make duro_workspace_add require approval (privilege escalation).
- Layer 1: Execution-path policy gate with fail-closed enforcement: Implemented policy_gate.py with scoped action IDs (tool:args_hash), breakglass override, and one-shot token consumption. Integrated at top of call_tool() in duro_mcp_server.py.
- Layer 2: Workspace allowlist + file op constraints: Implemented workspace_guard.py with path scoping, traversal detection (symlinks, unicode confusables), and privilege escalation controls. duro_workspace_add now requires approval for paths outside home directory.
- Layer 3: Secrets guard - no secrets in prompts/logs/memory: Implemented secrets_guard.py with 20+ pattern detection (API keys, tokens, passwords, DB URLs, PII), argument redaction for audit logs, sensitive tool blocking (memory/logging tools), and Bash env var exposure detection. Integrated into policy_gate.py as Layer 3 check. All tests passing.
- Security hardening: Post-execution output redaction + critical path deny list: Added post-execution output scanning (closes args-clean-output-leaks gap) with redaction to [REDACTED:hash]. Added critical path deny list (Windows/Program Files/etc) that blocks even with approval - only breakglass can override.
- Layer 6 hardening - fix 5 sharp edges in intent guard and prompt firewall: All fixes implemented: auto-intent issuance at call_tool, server-side _intent_id injection, vault_id canonical consistency, 8-byte collision resistance, Layer 6 → Layer 5 audit integration. All tests pass (Layer 6: 9/9, Secrets: 7/7, Browser: 8/8, Audit: 8/8). Committed as 679cce0.
- Layer 6 architecture fixes - move intent to user boundary, fix args hashing, entropy, audit chain: Fixed 5 architectural issues: (1) intent minting moved from call_tool to on_user_message with user_turn_id tracking, (2) _intent_id excluded from args_hash via INTERNAL_ARG_KEYS set, (3) secrets.token_hex(8) for proper 64-bit entropy, (4) verified vault_id == source_id is canonical, (5) added full audit chain: issued→consumed→blocked→wrapped. Committed as 1b9c3d9.
- Layer 6 fail-closed edges - bind tokens to turns, catch missing hooks: Added 4 fixes: (1) require_intent() checks current_user_turn_id is not None for fail-closed, (2) IntentToken now has turn_id field bound on issuance, (3) require_intent() validates token.turn_id matches current turn, (4) start_new_user_turn() uses secrets.token_hex(8), (5) INJECTION_DETECTED includes content_hash. Committed as 2f91210.
- Close turn_id=None hole in token validation: Tokens without turn_id binding now denied outright. No grace period. Catches old tokens, bugs where turn_id wasn't passed, any edge case producing unbound tokens. Committed as 637d11a.
- Add regression tests for turn-bound intent (unbound denied, wrong turn denied): Added test_unbound_token_denied() and test_old_token_denied_after_new_turn() to test_layer6.py. Both tests pass and prove the fail-closed behavior: unbound tokens denied with "missing turn binding", old tokens denied with "wrong turn". Committed as b685ea7.
- Verify duro-mcp state and run smoke tests after migration/reindex investigation: All systems operational: 4 migrations applied, git clean, Layer 6 tests pass (11/11), smoke tests pass (8/8), 1916 artifacts indexed, embedding queue drained. Readonly DB error was environment-specific sandbox artifact, not persistent issue.

## Stats
- Original size: 44135 chars
- Total learnings: 46
- Tasks completed: 46
- Failures logged: 0