# Plan Generated by Planify (Claude Code Integration)

**Generated**: 2026-02-15T02:18:04.764963
**Cost**: $0.00 (using Claude Code as LLM)

---

# Cartridge Memory System - Implementation Plan

## Summary
Build the Cartridge Memory System for Duro - a context management layer that intelligently loads procedural memory (skills) and project-specific rules (constitutions) into LLM context windows. The system prioritizes "what matters" over "everything," using precompiled renderings and smart retrieval.

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CONTEXT ASSEMBLER                         â”‚
â”‚  (decides what to load for this specific task)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼             â–¼             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SKILL PACKâ”‚  â”‚PROJECT PCKâ”‚  â”‚ TASK PACK â”‚
â”‚  (static) â”‚  â”‚  (stable) â”‚  â”‚ (dynamic) â”‚
â”‚  20-40K   â”‚  â”‚   1-3K    â”‚  â”‚   2-8K    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## File Structure

```
~/.agent/
â”œâ”€â”€ constitutions/
â”‚   â”œâ”€â”€ schema.ts           # TypeScript interface docs
â”‚   â”œâ”€â”€ msj.yaml            # Project constitution
â”‚   â””â”€â”€ cinematch.yaml
â”œâ”€â”€ skills/
â”‚   â”œâ”€â”€ schema.ts           # Skill schema v1.1
â”‚   â”œâ”€â”€ stats.json          # Telemetry (separate from definitions)
â”‚   â””â”€â”€ core/               # Always-loaded skills
â”‚       â””â”€â”€ git_commit.yaml
â””â”€â”€ lib/
    â”œâ”€â”€ context_assembler.py
    â”œâ”€â”€ constitution_loader.py
    â”œâ”€â”€ skill_loader.py
    â””â”€â”€ promotion_compactor.py
```

---

## STAGE 1: Constitution Format + Loader

### 1.1 Create constitutions/msj.yaml

```yaml
project_id: msj
name: My Swim Journey
version: "0.1.0"
updated_at: "2026-02-15T00:00:00Z"

north_star:
  statement: "Athletic energy + functional clarity for swimmers tracking progress."
  primary_user_job: "Check progress fast, understand trends, act immediately."
  tone: "Encouraging, data-driven, clean"

laws:
  - id: law.palette.primary
    rule: "Primary color is #8B5CF6 (purple); accent is #14B8A6 (teal)."
    strength: hard
    applies_to: [ui, brand]
    rationale: "Brand recognition + energy."
    provenance: [decision_20260215_003625_um4ofk]
    
  - id: law.typography.fonts
    rule: "Display font is Space Grotesk; body font is Inter."
    strength: hard
    applies_to: [ui, typography]
    provenance: [decision_20260215_003625_um4ofk]
    
  - id: law.spacing.system
    rule: "Use px-5 horizontal padding, pt-6 page headers, p-4 card padding."
    strength: soft
    applies_to: [components, layout]
    provenance: []

constraints:
  do_not:
    - "Overcrowd top fold (max 3 primary stats visible at once)."
    - "Use low-contrast text on colored surfaces."
    - "Break mobile-first responsive design (402px base)."
  accessibility:
    min_contrast: "WCAG AA"
    touch_target_min_px: 44

patterns_top:
  - id: pattern.stats.card_hierarchy
    pattern: "Big number â†’ tiny label â†’ optional delta chip."
    when: "Dashboard stat cards"
    value: "Glanceability"
    
  - id: pattern.list.item_structure
    pattern: "Icon left, title+subtitle stacked, value/badge right."
    when: "List items (events, meets, menu)"
    value: "Scannable rows"

deciding_axes:
  - "Glanceability beats decoration when showing data."
  - "Consistency beats novelty within the same screen."
  - "Athletic energy over corporate neutrality."

conflict_policy:
  order:
    - hard laws
    - accessibility constraints
    - soft laws
    - patterns
  tie_break: newer_version_wins
```

### 1.2 Create lib/constitution_loader.py

```python
"""
Constitution Loader - Load and validate project constitutions.
"""

import os
import re
import yaml
from pathlib import Path
from typing import Optional, Dict, Any
from datetime import datetime

CONSTITUTIONS_DIR = Path.home() / ".agent" / "constitutions"

# Cache: project_id -> (mtime, constitution)
_cache: Dict[str, tuple[float, Dict[str, Any]]] = {}


def sanitize_project_id(project_id: str) -> str:
    """Prevent path traversal attacks."""
    if not re.match(r'^[a-z0-9-]+$', project_id):
        raise ValueError(f"Invalid project_id: {project_id}")
    return project_id


def load_constitution(project_id: str) -> Optional[Dict[str, Any]]:
    """Load a project constitution with caching."""
    project_id = sanitize_project_id(project_id)
    filepath = CONSTITUTIONS_DIR / f"{project_id}.yaml"
    
    if not filepath.exists():
        return None
    
    mtime = filepath.stat().st_mtime
    
    # Check cache
    if project_id in _cache:
        cached_mtime, cached_const = _cache[project_id]
        if cached_mtime == mtime:
            return cached_const
    
    # Load and validate
    with open(filepath, 'r', encoding='utf-8') as f:
        data = yaml.safe_load(f)
    
    if not validate_constitution(data):
        raise ValueError(f"Invalid constitution: {project_id}")
    
    _cache[project_id] = (mtime, data)
    return data


def validate_constitution(data: Dict[str, Any]) -> bool:
    """Validate constitution structure."""
    required = ['project_id', 'name', 'version', 'north_star', 'laws', 'constraints']
    for field in required:
        if field not in data:
            return False
    
    # Validate laws
    for law in data.get('laws', []):
        if not all(k in law for k in ['id', 'rule', 'strength']):
            return False
        if law['strength'] not in ('hard', 'soft'):
            return False
    
    return True


def render_constitution(const: Dict[str, Any], mode: str = 'full') -> str:
    """Render constitution for context injection."""
    if mode == 'minimal':
        return _render_minimal(const)
    elif mode == 'compact':
        return _render_compact(const)
    else:
        return _render_full(const)


def _render_minimal(const: Dict[str, Any]) -> str:
    """~200 tokens: Just north star and hard laws."""
    lines = [
        f"# {const['name']}",
        f"{const['north_star']['statement']}",
        "",
        "## Hard Laws"
    ]
    for law in const.get('laws', []):
        if law['strength'] == 'hard':
            lines.append(f"- {law['rule']}")
    return "\n".join(lines)


def _render_compact(const: Dict[str, Any]) -> str:
    """~800 tokens: Laws + constraints + top patterns."""
    lines = [
        f"# {const['name']} Constitution",
        f"**North Star**: {const['north_star']['statement']}",
        f"**User Job**: {const['north_star']['primary_user_job']}",
        "",
        "## Laws"
    ]
    for law in const.get('laws', []):
        marker = "ðŸ”’" if law['strength'] == 'hard' else "ðŸ“‹"
        lines.append(f"{marker} {law['rule']}")
    
    lines.append("\n## Constraints")
    for item in const.get('constraints', {}).get('do_not', []):
        lines.append(f"- âŒ {item}")
    
    return "\n".join(lines)


def _render_full(const: Dict[str, Any]) -> str:
    """~2000 tokens: Everything including patterns and axes."""
    lines = [
        f"# {const['name']} Constitution v{const['version']}",
        "",
        "## North Star",
        f"**Vision**: {const['north_star']['statement']}",
        f"**User Job**: {const['north_star']['primary_user_job']}",
    ]
    if 'tone' in const['north_star']:
        lines.append(f"**Tone**: {const['north_star']['tone']}")
    
    lines.append("\n## Laws")
    for law in const.get('laws', []):
        strength = "HARD" if law['strength'] == 'hard' else "soft"
        lines.append(f"\n### {law['id']} [{strength}]")
        lines.append(law['rule'])
        if 'rationale' in law:
            lines.append(f"*Rationale: {law['rationale']}*")
    
    lines.append("\n## Constraints")
    lines.append("### Do Not")
    for item in const.get('constraints', {}).get('do_not', []):
        lines.append(f"- {item}")
    
    if 'accessibility' in const.get('constraints', {}):
        lines.append("\n### Accessibility")
        acc = const['constraints']['accessibility']
        if 'min_contrast' in acc:
            lines.append(f"- Contrast: {acc['min_contrast']}")
        if 'touch_target_min_px' in acc:
            lines.append(f"- Touch targets: â‰¥{acc['touch_target_min_px']}px")
    
    if const.get('patterns_top'):
        lines.append("\n## Top Patterns")
        for p in const['patterns_top']:
            lines.append(f"\n### {p['id']}")
            lines.append(f"**When**: {p['when']}")
            lines.append(f"**Pattern**: {p['pattern']}")
            lines.append(f"**Value**: {p['value']}")
    
    if const.get('deciding_axes'):
        lines.append("\n## Deciding Axes")
        for axis in const['deciding_axes']:
            lines.append(f"- {axis}")
    
    return "\n".join(lines)


def count_tokens(text: str) -> int:
    """Rough token count (words * 1.3)."""
    return int(len(text.split()) * 1.3)
```

### 1.3 Add MCP Tool

In `duro_mcp_server.py`, add:

```python
@server.tool()
async def duro_load_constitution(project_id: str, mode: str = "compact") -> str:
    """Load a project constitution for context injection.
    
    Args:
        project_id: Project identifier (e.g., 'msj', 'cinematch')
        mode: Rendering mode - 'minimal' (~200 tokens), 'compact' (~800), 'full' (~2000)
    """
    from lib.constitution_loader import load_constitution, render_constitution, count_tokens
    
    const = load_constitution(project_id)
    if not const:
        return f"No constitution found for project: {project_id}"
    
    rendered = render_constitution(const, mode)
    tokens = count_tokens(rendered)
    
    return f"## Constitution Loaded ({tokens} tokens)\n\n{rendered}"
```

---

## STAGE 2: Skill Format v1.1

### 2.1 Create skills/stats.json

```json
{
  "skill_git_commit": {
    "times_loaded": 47,
    "times_used": 45,
    "success_rate": 0.96,
    "last_used": "2026-02-15T10:30:00Z",
    "avg_tokens": 850,
    "utility_score": 0.92,
    "current_load_mode": "compact",
    "flagged_for_revision": false
  }
}
```

### 2.2 Create skills/core/git_commit.yaml

Full skill with precompiled renderings following Skill Schema v1.1.

---

## STAGE 3: Context Assembler

### 3.1 Create lib/context_assembler.py

Core functions:
- `assemble_context(task, project_id, budget)` - Main entry point
- `select_skills(task, budget)` - Trigger matching + ranking
- `select_project_pack(project_id)` - Load constitution
- Token counting and truncation with logging

### 3.2 Add MCP Tool

```python
@server.tool()
async def duro_assemble_context(
    task: str,
    project_id: Optional[str] = None,
    budget_tokens: int = 30000
) -> str:
    """Assemble optimized context for a task.
    
    Returns skill pack + project pack + retrieval hints.
    """
```

---

## STAGE 4: Promotion Compactor

### 4.1 Create lib/promotion_compactor.py

Core functions:
- `scan_decisions(since_days=7)` - Find promotion candidates
- `score_candidate(candidate)` - Apply scoring rules
- `promote_to_law/pattern/skill(candidate)` - Create artifacts
- Provenance tracking on all created artifacts

### 4.2 Add MCP Tool

```python
@server.tool()
async def duro_run_compactor(
    dry_run: bool = True,
    since_days: int = 7
) -> str:
    """Run the promotion compactor to graduate decisions into rules/patterns/skills.
    
    Args:
        dry_run: If True, show what would be promoted without changing anything
        since_days: How far back to scan for decisions
    """
```

---

## Risks

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Stats write contention | Medium | Low | Use file locking |
| Stale precompiled renderings | Medium | Medium | Add content hash, warn on mismatch |
| Invalid YAML syntax | Low | High | Validate on load, fail gracefully |
| Promotion spam | Low | Medium | Score threshold â‰¥5 + rate limit 3/run |
| Token budget exceeded | Medium | Medium | Hard cap + truncation + logging |

---

## Validation Steps

1. âœ… Load MSJ constitution â†’ verify <3K tokens
2. âœ… Load git_commit skill in all 3 modes â†’ verify token counts
3. âœ… Assemble context with 30K budget â†’ verify total â‰¤30K
4. âœ… Run compactor dry-run â†’ verify candidates scored correctly
5. âœ… Promote one decision â†’ verify provenance link valid

---

## Timeline

| Stage | Estimated Effort |
|-------|-----------------|
| Stage 1: Constitution | 2-3 hours |
| Stage 2: Skill Format | 2-3 hours |
| Stage 3: Context Assembler | 3-4 hours |
| Stage 4: Promotion Compactor | 2-3 hours |
| Testing & Polish | 2 hours |

**Total**: ~12-15 hours of implementation


---

_Generated by Planify via SuperAGI MCP | Zero external API cost_
