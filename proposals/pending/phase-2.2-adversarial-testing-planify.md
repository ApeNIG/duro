# Plan Generated by Planify (Claude Code Integration)

**Generated**: 2026-02-15T11:35:19.532012
**Cost**: $0.00 (using Claude Code as LLM)

---

# Phase 2.2: Adversarial Testing for Duro Memory System

**Generated**: 2026-02-15T11:35
**Method**: Planify (Architect/Critic/Integrator)
**Cost**: $0.00 (Claude Code as LLM)

---

## Overview

Build adversarial test suite that proves Duro's memory system is trustworthy under stress. Four test categories targeting different failure modes: semantic confusion, data corruption, temporal drift, and integrity tampering.

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                  ADVERSARIAL TEST SUITE                      │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌─────────────────┐  ┌─────────────────┐                   │
│  │ Retrieval Tests │  │ Injection Tests │                   │
│  │                 │  │                 │                   │
│  │ • Precision@k   │  │ • Conf creep    │                   │
│  │ • Confusion     │  │ • Pollution     │                   │
│  │ • Edge cases    │  │ • Isolation     │                   │
│  └────────┬────────┘  └────────┬────────┘                   │
│           │                    │                             │
│  ┌────────┴────────┐  ┌────────┴────────┐                   │
│  │ Decay Tests     │  │ Audit Tests     │                   │
│  │                 │  │                 │                   │
│  │ • Time mock     │  │ • Deletion      │                   │
│  │ • Formula       │  │ • Modification  │                   │
│  │ • Recency       │  │ • Replay        │                   │
│  └────────┬────────┘  └────────┬────────┘                   │
│           │                    │                             │
│           └─────────┬──────────┘                             │
│                     ▼                                        │
│           ┌─────────────────┐                                │
│           │ Harness         │                                │
│           │                 │                                │
│           │ • Isolated DB   │                                │
│           │ • Time control  │                                │
│           │ • Metrics       │                                │
│           └─────────────────┘                                │
└─────────────────────────────────────────────────────────────┘
```

## Risks Table

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Flaky embedding tests | High | Medium | Relative thresholds, model pinning |
| Test pollution | Medium | High | Isolated temp DB, pytest fixtures |
| CI timeout | Medium | Medium | Pre-download model or skip |
| Accidental prod wipe | Low | Critical | Path validation, UUID temp dirs |
| Tests pass but system broken | Low | High | Add negative tests |

## Task List

### Phase 0: Baseline (30 min)
- [ ] 0.1 Measure current retrieval precision with 10 sample queries
- [ ] 0.2 Document current decay formula from code
- [ ] 0.3 Document audit chain hash algorithm
- [ ] 0.4 Set targets based on baseline

### Phase A: Infrastructure (2 hours)
- [ ] A.1 Create tests/adversarial/ directory structure
- [ ] A.2 Create harness.py with IsolatedTestDB class
- [ ] A.3 Create conftest.py with fixtures
- [ ] A.4 Add freezegun to requirements (time mocking)
- [ ] A.5 Create fixtures/confusion_sets.json
- [ ] A.6 Create fixtures/bad_facts.json

### Phase B: Retrieval Tests (2 hours)
- [ ] B.1 Implement test_adversarial_retrieval.py
- [ ] B.2 Add precision@k calculation
- [ ] B.3 Add relative threshold tests (top > 2x second)
- [ ] B.4 Add edge cases: empty, unicode, long facts
- [ ] B.5 Add negative test: verify wrong facts rank low

### Phase C: Injection Tests (1.5 hours)
- [ ] C.1 Implement test_bad_memory_injection.py
- [ ] C.2 Test confidence isolation
- [ ] C.3 Test query pollution
- [ ] C.4 Add negative test: verify reinforcement DOES increase confidence

### Phase D: Decay Tests (1.5 hours)
- [ ] D.1 Implement test_staleness_decay.py
- [ ] D.2 Use freezegun for time control
- [ ] D.3 Verify decay formula exactly
- [ ] D.4 Verify pinned immunity
- [ ] D.5 Verify recency ranking

### Phase E: Audit Tests (2 hours)
- [ ] E.1 Implement test_audit_chain_attack.py
- [ ] E.2 Test deletion detection
- [ ] E.3 Test modification detection
- [ ] E.4 Test replay detection
- [ ] E.5 Test concurrent write handling
- [ ] E.6 Test recovery after detection

### Phase F: Integration (1 hour)
- [ ] F.1 Create run_adversarial_suite.py
- [ ] F.2 Create ADVERSARIAL_TESTING.md
- [ ] F.3 Add to .agent skills index (optional)
- [ ] F.4 Log results to Duro memory

## Success Metrics

| Metric | Target |
|--------|--------|
| Retrieval Precision@1 | >= 90% (or baseline + 10%) |
| Wrong-but-confident rate | < 5% |
| Bad fact confidence creep | 0% without reinforcement |
| Decay formula accuracy | Exact match to code |
| Audit tampering detection | 100% |
| Test suite runtime | < 60 seconds |

## Files to Create

```
~/.agent/
├── tests/
│   └── adversarial/
│       ├── __init__.py
│       ├── conftest.py
│       ├── harness.py
│       ├── fixtures/
│       │   ├── confusion_sets.json
│       │   └── bad_facts.json
│       ├── test_adversarial_retrieval.py
│       ├── test_bad_memory_injection.py
│       ├── test_staleness_decay.py
│       ├── test_audit_chain_attack.py
│       └── run_adversarial_suite.py
└── ADVERSARIAL_TESTING.md
```

## Validation Steps

1. Run full suite: `python run_adversarial_suite.py`
2. Verify all tests pass
3. Intentionally break one thing, verify test catches it
4. Run in CI (if applicable)
5. Log final metrics to Duro

## Critic's Concerns Addressed

| Concern | Resolution |
|---------|------------|
| No baseline measurement | Added Phase 0 to measure current state |
| Embedding model version | Pin version in test constants |
| Concurrent access | Added to Phase E (audit tests) |
| Recovery testing | Added E.6 recovery after detection |
| Edge cases | Added B.4 for empty/unicode/long |
| Test DB safety | UUID temp dirs, path validation |
| Flaky thresholds | Use relative thresholds |
| Time dependency | Use freezegun library |

---

_Generated by Planify via Claude Code | Zero external API cost_


---

## Codex Review (2026-02-15)

**Model**: gpt-5.3-codex | **Tokens**: 113,393 | **Scope**: `.agent` repo (duro-mcp sandbox-restricted)

### 1. Data Integrity Risks - Specific Tests

| # | Test | Description | File Refs |
|---|------|-------------|-----------|
| 1.1 | Audit chain tamper | Delete one JSONL row, verify chain validation fails (`entry_hash`/`prev_hash` continuity) | `memory/logs/deletions.jsonl` |
| 1.2 | Replay attack | Duplicate old deletion entry at end of log, assert replay detected | `memory/logs/deletions.jsonl` |
| 1.3 | Orphan embedding consistency | Delete artifact rows while leaving embedding rows, verify orphan detection and safe prune | `skills/ops/duro_bash_ops.py:160,183` |
| 1.4 | Dedup collision | Force same short hash tag (`hash:<12hex>`) for different learnings, verify no false "already promoted" | `skills/memory/promote_learnings.py:107,131` |
| 1.5 | SQLite corruption gate | Inject low-level DB corruption, verify health check fails hard (not warn) | `skills/ops/crash_drill_verify.py:238`, `duro_bash_ops.py:67` |

### 2. Concurrency Issues - Specific Tests

| # | Test | Description | File Refs |
|---|------|-------------|-----------|
| 2.1 | Reembed vs prune race | Run `reembed` and `prune --apply` concurrently, assert no lost fresh embeddings | `skills/ops/duro_bash_ops.py:93,149` |
| 2.2 | Double reembed race | Two workers upsert same `artifact_id` simultaneously, assert idempotent final row | `skills/ops/crash_drill_verify.py:143`, `duro_bash_ops.py:124` |
| 2.3 | Crash mid-repair | Kill process mid-reembed, verify `repairs` doesn't remain permanently `pending` | `skills/ops/crash_drill_verify.py:182,211` |
| 2.4 | Concurrent audit append | Multiple deletes at once, assert hash-chain remains linear without forked `prev_hash` | `memory/logs/deletions.jsonl`, `audit_repairs.jsonl` |

### 3. Memory/Embedding Failures - Specific Tests

| # | Test | Description | File Refs |
|---|------|-------------|-----------|
| 3.1 | Backend unavailable | Missing fastembed, verify degraded mode keeps system operational | `skills/ops/crash_drill_verify.py:108`, `duro_bash_ops.py:99` |
| 3.2 | Null vector return | Assert failure counted, no corrupt embedding row written | `skills/ops/crash_drill_verify.py:138,153` |
| 3.3 | Hybrid search fallback | Disable vector path, verify fallback still returns deterministic results | `skills/ops/crash_drill_verify.py:272,276` |
| 3.4 | Model drift | Reembed with different `model_name`, verify query ranking and no silent mixing | `skills/ops/crash_drill_verify.py:142` |
| 3.5 | Wrong-but-confident retrieval | Confusion sets regression under similar-but-wrong facts | `proposals/pending/phase-2.2-adversarial-testing.md:29,45` |

### 4. Recovery Scenarios - Specific Tests

| # | Test | Description | File Refs |
|---|------|-------------|-----------|
| 4.1 | Crash drill E2E | Crash mid-operation, restart, verify DB integrity + semantic search + no stuck repairs | `skills/ops/crash_drill_verify.py:5,201,229` |
| 4.2 | Audit chain repair | Simulate legacy/broken chain, run repair script, validate repaired hash record | `memory/logs/audit_repairs.jsonl` |
| 4.3 | Backup restore | Recovery from accidental delete using `backup_path`, verify re-indexes and orphans cleaned | `memory/logs/deletions.jsonl` (backup_path entries) |
| 4.4 | WAL recovery | Simulate unclean shutdown with `index.db-wal`/`index.db-shm`, verify startup health passes | `memory/index.db-wal`, `duro_bash_ops.py:82` |
| 4.5 | Post-tamper recovery | After audit tamper detection, verify controlled reset returns `chain_valid=True` | `phase-2.2-adversarial-testing.md:141` |

### Implementation Priority

Based on Codex analysis of existing code patterns:

1. **High Priority** (gaps in current testing):
   - 1.4 Dedup collision (hash truncation risk)
   - 2.1 Reembed vs prune race (no concurrent test exists)
   - 3.4 Model drift (version mixing risk)

2. **Medium Priority** (partially covered):
   - 1.1-1.3 Audit chain tests (some manual tests in deletions.jsonl)
   - 4.1 Crash drill (crash_drill_verify.py exists but needs adversarial scenarios)

3. **Lower Priority** (existing coverage):
   - 3.1-3.3 Embedding failures (crash_drill_verify.py covers basics)
   - 4.2-4.4 Recovery (audit_repairs.jsonl shows manual testing done)

---

_Codex Review appended 2026-02-15 | gpt-5.3-codex_

---

_Generated by Planify via SuperAGI MCP | Zero external API cost_
